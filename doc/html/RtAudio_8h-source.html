<HTML>
<HEAD>
<TITLE>The RtAudio Tutorial</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<a class="qindex" href="index.html">Tutorial</a> &nbsp; <a class="qindex" href="annotated.html">Class/Enum List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </CENTER>
<HR>
<!-- Generated by Doxygen 1.3.4 -->
<h1>RtAudio.h</h1><div class="fragment"><pre>00001 <span class="comment">/************************************************************************/</span>
00038 <span class="comment">/************************************************************************/</span>
00039 
00040 <span class="comment">// RtAudio: Version 3.0, 11 March 2004</span>
00041 
00042 <span class="preprocessor">#ifndef __RTAUDIO_H</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define __RTAUDIO_H</span>
00044 <span class="preprocessor"></span>
00045 <span class="preprocessor">#include "RtError.h"</span>
00046 <span class="preprocessor">#include &lt;string&gt;</span>
00047 <span class="preprocessor">#include &lt;vector&gt;</span>
00048 
00049 <span class="comment">// Operating system dependent thread functionality.</span>
00050 <span class="preprocessor">#if defined(__WINDOWS_DS__) || defined(__WINDOWS_ASIO__)</span>
00051 <span class="preprocessor"></span><span class="preprocessor">  #include &lt;windows.h&gt;</span>
00052 <span class="preprocessor">  #include &lt;process.h&gt;</span>
00053 
00054   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ThreadHandle;
00055   <span class="keyword">typedef</span> CRITICAL_SECTION StreamMutex;
00056 
00057 <span class="preprocessor">#else // Various unix flavors with pthread support.</span>
00058 <span class="preprocessor"></span><span class="preprocessor">  #include &lt;pthread.h&gt;</span>
00059 
00060   <span class="keyword">typedef</span> pthread_t ThreadHandle;
00061   <span class="keyword">typedef</span> pthread_mutex_t StreamMutex;
00062 
00063 <span class="preprocessor">#endif</span>
00064 <span class="preprocessor"></span>
00065 <span class="comment">// This global structure type is used to pass callback information</span>
00066 <span class="comment">// between the private RtAudio stream structure and global callback</span>
00067 <span class="comment">// handling functions.</span>
00068 <span class="keyword">struct </span>CallbackInfo {
00069   <span class="keywordtype">void</span> *object;    <span class="comment">// Used as a "this" pointer.</span>
00070   ThreadHandle thread;
00071   <span class="keywordtype">bool</span> usingCallback;
00072   <span class="keywordtype">void</span> *callback;
00073   <span class="keywordtype">void</span> *userData;
00074   <span class="keywordtype">void</span> *apiInfo;   <span class="comment">// void pointer for API specific callback information</span>
00075 
00076   <span class="comment">// Default constructor.</span>
00077   CallbackInfo()
00078     :object(0), usingCallback(false), callback(0),
00079      userData(0), apiInfo(0) {}
00080 };
00081 
00082 <span class="comment">// Support for signed integers and floats.  Audio data fed to/from</span>
00083 <span class="comment">// the tickStream() routine is assumed to ALWAYS be in host</span>
00084 <span class="comment">// byte order.  The internal routines will automatically take care of</span>
00085 <span class="comment">// any necessary byte-swapping between the host format and the</span>
00086 <span class="comment">// soundcard.  Thus, endian-ness is not a concern in the following</span>
00087 <span class="comment">// format definitions.</span>
00088 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> RtAudioFormat;
00089 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_SINT8 = 0x1;    
00090 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_SINT16 = 0x2;   
00091 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_SINT24 = 0x4;   
00092 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_SINT32 = 0x8;   
00093 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_FLOAT32 = 0x10; 
00094 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_FLOAT64 = 0x20; 
00096 <span class="keyword">typedef</span> int (*RtAudioCallback)(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> bufferSize, <span class="keywordtype">void</span> *userData);
00097 
<a name="l00099"></a><a class="code" href="structRtAudioDeviceInfo.html">00099</a> <span class="keyword">struct </span><a class="code" href="structRtAudioDeviceInfo.html">RtAudioDeviceInfo</a> {
<a name="l00100"></a><a class="code" href="structRtAudioDeviceInfo.html#o0">00100</a>   std::string <a class="code" href="structRtAudioDeviceInfo.html#o0">name</a>;      
<a name="l00101"></a><a class="code" href="structRtAudioDeviceInfo.html#o1">00101</a>   <span class="keywordtype">bool</span> <a class="code" href="structRtAudioDeviceInfo.html#o1">probed</a>;          
<a name="l00102"></a><a class="code" href="structRtAudioDeviceInfo.html#o2">00102</a>   <span class="keywordtype">int</span> <a class="code" href="structRtAudioDeviceInfo.html#o2">outputChannels</a>;   
<a name="l00103"></a><a class="code" href="structRtAudioDeviceInfo.html#o3">00103</a>   <span class="keywordtype">int</span> <a class="code" href="structRtAudioDeviceInfo.html#o3">inputChannels</a>;    
<a name="l00104"></a><a class="code" href="structRtAudioDeviceInfo.html#o4">00104</a>   <span class="keywordtype">int</span> <a class="code" href="structRtAudioDeviceInfo.html#o4">duplexChannels</a>;   
<a name="l00105"></a><a class="code" href="structRtAudioDeviceInfo.html#o5">00105</a>   <span class="keywordtype">bool</span> <a class="code" href="structRtAudioDeviceInfo.html#o5">isDefault</a>;       
<a name="l00106"></a><a class="code" href="structRtAudioDeviceInfo.html#o6">00106</a>   std::vector&lt;int&gt; <a class="code" href="structRtAudioDeviceInfo.html#o6">sampleRates</a>; 
<a name="l00107"></a><a class="code" href="structRtAudioDeviceInfo.html#o7">00107</a>   RtAudioFormat <a class="code" href="structRtAudioDeviceInfo.html#o7">nativeFormats</a>;  
00109   <span class="comment">// Default constructor.</span>
00110   <a class="code" href="structRtAudioDeviceInfo.html">RtAudioDeviceInfo</a>()
00111     :<a class="code" href="structRtAudioDeviceInfo.html#o1">probed</a>(false), <a class="code" href="structRtAudioDeviceInfo.html#o2">outputChannels</a>(0), <a class="code" href="structRtAudioDeviceInfo.html#o3">inputChannels</a>(0),
00112        <a class="code" href="structRtAudioDeviceInfo.html#o4">duplexChannels</a>(0), <a class="code" href="structRtAudioDeviceInfo.html#o5">isDefault</a>(false), <a class="code" href="structRtAudioDeviceInfo.html#o7">nativeFormats</a>(0) {}
00113 };
00114 
00115 <span class="comment">// **************************************************************** //</span>
00116 <span class="comment">//</span>
00117 <span class="comment">// RtApi class declaration.</span>
00118 <span class="comment">//</span>
00119 <span class="comment">// Note that RtApi is an abstract base class and cannot be</span>
00120 <span class="comment">// explicitly instantiated.  The class RtAudio will create an</span>
00121 <span class="comment">// instance of an RtApi subclass (RtApiOss, RtApiAlsa,</span>
00122 <span class="comment">// RtApiJack, RtApiCore, RtApiAl, RtApiDs, or RtApiAsio).</span>
00123 <span class="comment">//</span>
00124 <span class="comment">// **************************************************************** //</span>
00125 
00126 <span class="keyword">class </span>RtApi
00127 {
00128 <span class="keyword">public</span>:
00129 
00130   RtApi();
00131   <span class="keyword">virtual</span> ~RtApi();
00132   <span class="keywordtype">void</span> openStream( <span class="keywordtype">int</span> outputDevice, <span class="keywordtype">int</span> outputChannels,
00133                    <span class="keywordtype">int</span> inputDevice, <span class="keywordtype">int</span> inputChannels,
00134                    RtAudioFormat format, <span class="keywordtype">int</span> sampleRate,
00135                    <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00136   <span class="keyword">virtual</span> <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData ) = 0;
00137   <span class="keyword">virtual</span> <span class="keywordtype">void</span> cancelStreamCallback() = 0;
00138   <span class="keywordtype">int</span> getDeviceCount(<span class="keywordtype">void</span>);
00139   <a class="code" href="structRtAudioDeviceInfo.html">RtAudioDeviceInfo</a> getDeviceInfo( <span class="keywordtype">int</span> device );
00140   <span class="keywordtype">char</span> * <span class="keyword">const</span> getStreamBuffer();
00141   <span class="keyword">virtual</span> <span class="keywordtype">void</span> tickStream() = 0;
00142   <span class="keyword">virtual</span> <span class="keywordtype">void</span> closeStream();
00143   <span class="keyword">virtual</span> <span class="keywordtype">void</span> startStream() = 0;
00144   <span class="keyword">virtual</span> <span class="keywordtype">void</span> stopStream() = 0;
00145   <span class="keyword">virtual</span> <span class="keywordtype">void</span> abortStream() = 0;
00146 
00147 <span class="keyword">protected</span>:
00148 
00149   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAX_SAMPLE_RATES;
00150   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> SAMPLE_RATES[];
00151 
00152   <span class="keyword">enum</span> { FAILURE, SUCCESS };
00153 
00154   <span class="keyword">enum</span> StreamMode {
00155     OUTPUT,
00156     INPUT,
00157     DUPLEX,
00158     UNINITIALIZED = -75
00159   };
00160 
00161   <span class="keyword">enum</span> StreamState {
00162     STREAM_STOPPED,
00163     STREAM_RUNNING
00164   };
00165 
00166   <span class="comment">// A protected structure for audio streams.</span>
00167   <span class="keyword">struct </span>RtApiStream {
00168     <span class="keywordtype">int</span> device[2];          <span class="comment">// Playback and record, respectively.</span>
00169     <span class="keywordtype">void</span> *apiHandle;        <span class="comment">// void pointer for API specific stream handle information</span>
00170     StreamMode mode;         <span class="comment">// OUTPUT, INPUT, or DUPLEX.</span>
00171     StreamState state;       <span class="comment">// STOPPED or RUNNING</span>
00172     <span class="keywordtype">char</span> *userBuffer;
00173     <span class="keywordtype">char</span> *deviceBuffer;
00174     <span class="keywordtype">bool</span> doConvertBuffer[2]; <span class="comment">// Playback and record, respectively.</span>
00175     <span class="keywordtype">bool</span> deInterleave[2];    <span class="comment">// Playback and record, respectively.</span>
00176     <span class="keywordtype">bool</span> doByteSwap[2];      <span class="comment">// Playback and record, respectively.</span>
00177     <span class="keywordtype">int</span> sampleRate;
00178     <span class="keywordtype">int</span> bufferSize;
00179     <span class="keywordtype">int</span> nBuffers;
00180     <span class="keywordtype">int</span> nUserChannels[2];    <span class="comment">// Playback and record, respectively.</span>
00181     <span class="keywordtype">int</span> nDeviceChannels[2];  <span class="comment">// Playback and record channels, respectively.</span>
00182     RtAudioFormat userFormat;
00183     RtAudioFormat deviceFormat[2]; <span class="comment">// Playback and record, respectively.</span>
00184     StreamMutex mutex;
00185     CallbackInfo callbackInfo;
00186 
00187     RtApiStream()
00188       :apiHandle(0), userBuffer(0), deviceBuffer(0) {}
00189     <span class="comment">//      :apiHandle(0), mode(UNINITIALIZED), state(STREAM_STOPPED),</span>
00190     <span class="comment">//       userBuffer(0), deviceBuffer(0) {}</span>
00191   };
00192 
00193   <span class="comment">// A protected device structure for audio devices.</span>
00194   <span class="keyword">struct </span>RtApiDevice {
00195     std::string name;      
00196     <span class="keywordtype">bool</span> probed;           
00197     <span class="keywordtype">void</span> *apiDeviceId;     <span class="comment">// void pointer for API specific device information</span>
00198     <span class="keywordtype">int</span> maxOutputChannels; 
00199     <span class="keywordtype">int</span> maxInputChannels;  
00200     <span class="keywordtype">int</span> maxDuplexChannels; 
00201     <span class="keywordtype">int</span> minOutputChannels; 
00202     <span class="keywordtype">int</span> minInputChannels;  
00203     <span class="keywordtype">int</span> minDuplexChannels; 
00204     <span class="keywordtype">bool</span> hasDuplexSupport; 
00205     <span class="keywordtype">bool</span> isDefault;        
00206     std::vector&lt;int&gt; sampleRates; 
00207     RtAudioFormat nativeFormats;  
00209     <span class="comment">// Default constructor.</span>
00210     RtApiDevice()
00211       :probed(false), apiDeviceId(0), maxOutputChannels(0), maxInputChannels(0),
00212        maxDuplexChannels(0), minOutputChannels(0), minInputChannels(0),
00213        minDuplexChannels(0), isDefault(false), nativeFormats(0) {}
00214   };
00215 
00216   <span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">short</span> Int16;
00217   <span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">int</span> Int32;
00218   <span class="keyword">typedef</span> <span class="keywordtype">float</span> Float32;
00219   <span class="keyword">typedef</span> <span class="keywordtype">double</span> Float64;
00220 
00221   <span class="keywordtype">char</span> message_[256];
00222   <span class="keywordtype">int</span> nDevices_;
00223   std::vector&lt;RtApiDevice&gt; devices_;
00224   RtApiStream stream_;
00225 
00230   <span class="keyword">virtual</span> <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>) = 0;
00231 
00240   <span class="keyword">virtual</span> <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00241 
00250   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00251                                 <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00252                                 <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00253 
00258   <span class="keyword">virtual</span> <span class="keywordtype">int</span> getDefaultInputDevice(<span class="keywordtype">void</span>);
00259 
00264   <span class="keyword">virtual</span> <span class="keywordtype">int</span> getDefaultOutputDevice(<span class="keywordtype">void</span>);
00265 
00267   <span class="keywordtype">void</span> clearDeviceInfo( RtApiDevice *info );
00268 
00270   <span class="keywordtype">void</span> clearStreamInfo();
00271 
00273   <span class="keywordtype">void</span> error( RtError::Type type );
00274 
00279   <span class="keywordtype">void</span> verifyStream();
00280 
00285   <span class="keywordtype">void</span> convertStreamBuffer( StreamMode mode );
00286 
00288   <span class="keywordtype">void</span> byteSwapBuffer( <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> samples, RtAudioFormat format );
00289 
00291   <span class="keywordtype">int</span> formatBytes( RtAudioFormat format );
00292 };
00293 
00294 
00295 <span class="comment">// **************************************************************** //</span>
00296 <span class="comment">//</span>
00297 <span class="comment">// RtAudio class declaration.</span>
00298 <span class="comment">//</span>
00299 <span class="comment">// RtAudio is a "controller" used to select an available audio i/o</span>
00300 <span class="comment">// interface.  It presents a common API for the user to call but all</span>
00301 <span class="comment">// functionality is implemented by the class RtAudioApi and its</span>
00302 <span class="comment">// subclasses.  RtAudio creates an instance of an RtAudioApi subclass</span>
00303 <span class="comment">// based on the user's API choice.  If no choice is made, RtAudio</span>
00304 <span class="comment">// attempts to make a "logical" API selection.</span>
00305 <span class="comment">//</span>
00306 <span class="comment">// **************************************************************** //</span>
00307 
<a name="l00308"></a><a class="code" href="classRtAudio.html">00308</a> <span class="keyword">class </span><a class="code" href="classRtAudio.html">RtAudio</a>
00309 {
00310 <span class="keyword">public</span>:
00311 
<a name="l00313"></a><a class="code" href="classRtAudio.html#w8">00313</a>   <span class="keyword">enum</span> <a class="code" href="classRtAudio.html#w8">RtAudioApi</a> {
00314     <a class="code" href="classRtAudio.html#w8w0">UNSPECIFIED</a>,    
00315     <a class="code" href="classRtAudio.html#w8w1">LINUX_ALSA</a>,     
00316     <a class="code" href="classRtAudio.html#w8w2">LINUX_OSS</a>,      
00317     <a class="code" href="classRtAudio.html#w8w3">LINUX_JACK</a>,     
00318     <a class="code" href="classRtAudio.html#w8w4">MACOSX_CORE</a>,    
00319     <a class="code" href="classRtAudio.html#w8w5">IRIX_AL</a>,        
00320     <a class="code" href="classRtAudio.html#w8w6">WINDOWS_ASIO</a>,   
00321     <a class="code" href="classRtAudio.html#w8w7">WINDOWS_DS</a>      
00322   };
00323 
00325 
00335   <a class="code" href="classRtAudio.html#a0">RtAudio</a>( RtAudioApi api=UNSPECIFIED );
00336 
00338 
00349   <a class="code" href="classRtAudio.html#a0">RtAudio</a>( <span class="keywordtype">int</span> outputDevice, <span class="keywordtype">int</span> outputChannels,
00350            <span class="keywordtype">int</span> inputDevice, <span class="keywordtype">int</span> inputChannels,
00351            RtAudioFormat format, <span class="keywordtype">int</span> sampleRate,
00352            <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers, RtAudioApi api=UNSPECIFIED );
00353 
00355 
00359   <a class="code" href="classRtAudio.html#a2">~RtAudio</a>();
00360 
00362 
00388   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a3">openStream</a>( <span class="keywordtype">int</span> outputDevice, <span class="keywordtype">int</span> outputChannels,
00389                    <span class="keywordtype">int</span> inputDevice, <span class="keywordtype">int</span> inputChannels,
00390                    RtAudioFormat format, <span class="keywordtype">int</span> sampleRate,
00391                    <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00392 
00394 
<a name="l00413"></a><a class="code" href="classRtAudio.html#a4">00413</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a4">setStreamCallback</a>(RtAudioCallback callback, <span class="keywordtype">void</span> *userData) { rtapi_-&gt;setStreamCallback( callback, userData ); };
00414 
00416 
<a name="l00423"></a><a class="code" href="classRtAudio.html#a5">00423</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a5">cancelStreamCallback</a>() { rtapi_-&gt;cancelStreamCallback(); };
00424 
<a name="l00426"></a><a class="code" href="classRtAudio.html#a6">00426</a>   <span class="keywordtype">int</span> <a class="code" href="classRtAudio.html#a6">getDeviceCount</a>(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> rtapi_-&gt;getDeviceCount(); };
00427 
00429 
<a name="l00437"></a><a class="code" href="classRtAudio.html#a7">00437</a>   <a class="code" href="structRtAudioDeviceInfo.html">RtAudioDeviceInfo</a> <a class="code" href="classRtAudio.html#a7">getDeviceInfo</a>(<span class="keywordtype">int</span> device) { <span class="keywordflow">return</span> rtapi_-&gt;getDeviceInfo( device ); };
00438 
00440 
<a name="l00445"></a><a class="code" href="classRtAudio.html#a8">00445</a>   <span class="keywordtype">char</span> * <span class="keyword">const</span> <a class="code" href="classRtAudio.html#a8">getStreamBuffer</a>() { <span class="keywordflow">return</span> rtapi_-&gt;getStreamBuffer(); };
00446 
00448 
<a name="l00453"></a><a class="code" href="classRtAudio.html#a9">00453</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a9">tickStream</a>() { rtapi_-&gt;tickStream(); };
00454 
00456 
<a name="l00460"></a><a class="code" href="classRtAudio.html#a10">00460</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a10">closeStream</a>()  { rtapi_-&gt;closeStream(); };
00461 
00463 
<a name="l00467"></a><a class="code" href="classRtAudio.html#a11">00467</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a11">startStream</a>() { rtapi_-&gt;startStream(); };
00468 
00470 
<a name="l00474"></a><a class="code" href="classRtAudio.html#a12">00474</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a12">stopStream</a>() { rtapi_-&gt;stopStream(); };
00475 
00477 
<a name="l00481"></a><a class="code" href="classRtAudio.html#a13">00481</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a13">abortStream</a>() { rtapi_-&gt;abortStream(); };
00482 
00483 
00484  <span class="keyword">protected</span>:
00485 
00486   <span class="keywordtype">void</span> initialize( RtAudioApi api );
00487 
00488   RtApi *rtapi_;
00489 };
00490 
00491 
00492 <span class="comment">// RtApi Subclass prototypes.</span>
00493 
00494 <span class="preprocessor">#if defined(__LINUX_ALSA__)</span>
00495 <span class="preprocessor"></span>
00496 <span class="keyword">class </span>RtApiAlsa: <span class="keyword">public</span> RtApi
00497 {
00498 <span class="keyword">public</span>:
00499 
00500   RtApiAlsa();
00501   ~RtApiAlsa();
00502   <span class="keywordtype">void</span> tickStream();
00503   <span class="keywordtype">void</span> closeStream();
00504   <span class="keywordtype">void</span> startStream();
00505   <span class="keywordtype">void</span> stopStream();
00506   <span class="keywordtype">void</span> abortStream();
00507   <span class="keywordtype">int</span> streamWillBlock();
00508   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00509   <span class="keywordtype">void</span> cancelStreamCallback();
00510 
00511   <span class="keyword">private</span>:
00512 
00513   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00514   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00515   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00516                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00517                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00518 };
00519 
00520 <span class="preprocessor">#endif</span>
00521 <span class="preprocessor"></span>
00522 <span class="preprocessor">#if defined(__LINUX_JACK__)</span>
00523 <span class="preprocessor"></span>
00524 <span class="keyword">class </span>RtApiJack: <span class="keyword">public</span> RtApi
00525 {
00526 <span class="keyword">public</span>:
00527 
00528   RtApiJack();
00529   ~RtApiJack();
00530   <span class="keywordtype">void</span> tickStream();
00531   <span class="keywordtype">void</span> closeStream();
00532   <span class="keywordtype">void</span> startStream();
00533   <span class="keywordtype">void</span> stopStream();
00534   <span class="keywordtype">void</span> abortStream();
00535   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00536   <span class="keywordtype">void</span> cancelStreamCallback();
00537   <span class="comment">// This function is intended for internal use only.  It must be</span>
00538   <span class="comment">// public because it is called by the internal callback handler,</span>
00539   <span class="comment">// which is not a member of RtAudio.  External use of this function</span>
00540   <span class="comment">// will most likely produce highly undesireable results!</span>
00541   <span class="keywordtype">void</span> callbackEvent( <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nframes );
00542 
00543   <span class="keyword">private</span>:
00544 
00545   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00546   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00547   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00548                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00549                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00550 };
00551 
00552 <span class="preprocessor">#endif</span>
00553 <span class="preprocessor"></span>
00554 <span class="preprocessor">#if defined(__LINUX_OSS__)</span>
00555 <span class="preprocessor"></span>
00556 <span class="keyword">class </span>RtApiOss: <span class="keyword">public</span> RtApi
00557 {
00558 <span class="keyword">public</span>:
00559 
00560   RtApiOss();
00561   ~RtApiOss();
00562   <span class="keywordtype">void</span> tickStream();
00563   <span class="keywordtype">void</span> closeStream();
00564   <span class="keywordtype">void</span> startStream();
00565   <span class="keywordtype">void</span> stopStream();
00566   <span class="keywordtype">void</span> abortStream();
00567   <span class="keywordtype">int</span> streamWillBlock();
00568   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00569   <span class="keywordtype">void</span> cancelStreamCallback();
00570 
00571   <span class="keyword">private</span>:
00572 
00573   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00574   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00575   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00576                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00577                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00578 };
00579 
00580 <span class="preprocessor">#endif</span>
00581 <span class="preprocessor"></span>
00582 <span class="preprocessor">#if defined(__MACOSX_CORE__)</span>
00583 <span class="preprocessor"></span>
00584 <span class="preprocessor">#include &lt;CoreAudio/AudioHardware.h&gt;</span>
00585 
00586 <span class="keyword">class </span>RtApiCore: <span class="keyword">public</span> RtApi
00587 {
00588 <span class="keyword">public</span>:
00589 
00590   RtApiCore();
00591   ~RtApiCore();
00592   <span class="keywordtype">int</span> getDefaultOutputDevice(<span class="keywordtype">void</span>);
00593   <span class="keywordtype">int</span> getDefaultInputDevice(<span class="keywordtype">void</span>);
00594   <span class="keywordtype">void</span> tickStream();
00595   <span class="keywordtype">void</span> closeStream();
00596   <span class="keywordtype">void</span> startStream();
00597   <span class="keywordtype">void</span> stopStream();
00598   <span class="keywordtype">void</span> abortStream();
00599   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00600   <span class="keywordtype">void</span> cancelStreamCallback();
00601 
00602   <span class="comment">// This function is intended for internal use only.  It must be</span>
00603   <span class="comment">// public because it is called by the internal callback handler,</span>
00604   <span class="comment">// which is not a member of RtAudio.  External use of this function</span>
00605   <span class="comment">// will most likely produce highly undesireable results!</span>
00606   <span class="keywordtype">void</span> callbackEvent( AudioDeviceID deviceId, <span class="keywordtype">void</span> *inData, <span class="keywordtype">void</span> *outData );
00607 
00608   <span class="keyword">private</span>:
00609 
00610   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00611   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00612   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00613                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00614                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00615 };
00616 
00617 <span class="preprocessor">#endif</span>
00618 <span class="preprocessor"></span>
00619 <span class="preprocessor">#if defined(__WINDOWS_DS__)</span>
00620 <span class="preprocessor"></span>
00621 <span class="keyword">class </span>RtApiDs: <span class="keyword">public</span> RtApi
00622 {
00623 <span class="keyword">public</span>:
00624 
00625   RtApiDs();
00626   ~RtApiDs();
00627   <span class="keywordtype">int</span> getDefaultOutputDevice(<span class="keywordtype">void</span>);
00628   <span class="keywordtype">int</span> getDefaultInputDevice(<span class="keywordtype">void</span>);
00629   <span class="keywordtype">void</span> tickStream();
00630   <span class="keywordtype">void</span> closeStream();
00631   <span class="keywordtype">void</span> startStream();
00632   <span class="keywordtype">void</span> stopStream();
00633   <span class="keywordtype">void</span> abortStream();
00634   <span class="keywordtype">int</span> streamWillBlock();
00635   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00636   <span class="keywordtype">void</span> cancelStreamCallback();
00637 
00638   <span class="keyword">private</span>:
00639 
00640   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00641   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00642   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00643                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00644                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00645 };
00646 
00647 <span class="preprocessor">#endif</span>
00648 <span class="preprocessor"></span>
00649 <span class="preprocessor">#if defined(__WINDOWS_ASIO__)</span>
00650 <span class="preprocessor"></span>
00651 <span class="keyword">class </span>RtApiAsio: <span class="keyword">public</span> RtApi
00652 {
00653 <span class="keyword">public</span>:
00654 
00655   RtApiAsio();
00656   ~RtApiAsio();
00657   <span class="keywordtype">void</span> tickStream();
00658   <span class="keywordtype">void</span> closeStream();
00659   <span class="keywordtype">void</span> startStream();
00660   <span class="keywordtype">void</span> stopStream();
00661   <span class="keywordtype">void</span> abortStream();
00662   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00663   <span class="keywordtype">void</span> cancelStreamCallback();
00664 
00665   <span class="comment">// This function is intended for internal use only.  It must be</span>
00666   <span class="comment">// public because it is called by the internal callback handler,</span>
00667   <span class="comment">// which is not a member of RtAudio.  External use of this function</span>
00668   <span class="comment">// will most likely produce highly undesireable results!</span>
00669   <span class="keywordtype">void</span> callbackEvent( <span class="keywordtype">long</span> bufferIndex );
00670 
00671   <span class="keyword">private</span>:
00672 
00673   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00674   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00675   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00676                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00677                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00678 };
00679 
00680 <span class="preprocessor">#endif</span>
00681 <span class="preprocessor"></span>
00682 <span class="preprocessor">#if defined(__IRIX_AL__)</span>
00683 <span class="preprocessor"></span>
00684 <span class="keyword">class </span>RtApiAl: <span class="keyword">public</span> RtApi
00685 {
00686 <span class="keyword">public</span>:
00687 
00688   RtApiAl();
00689   ~RtApiAl();
00690   <span class="keywordtype">int</span> getDefaultOutputDevice(<span class="keywordtype">void</span>);
00691   <span class="keywordtype">int</span> getDefaultInputDevice(<span class="keywordtype">void</span>);
00692   <span class="keywordtype">void</span> tickStream();
00693   <span class="keywordtype">void</span> closeStream();
00694   <span class="keywordtype">void</span> startStream();
00695   <span class="keywordtype">void</span> stopStream();
00696   <span class="keywordtype">void</span> abortStream();
00697   <span class="keywordtype">int</span> streamWillBlock();
00698   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00699   <span class="keywordtype">void</span> cancelStreamCallback();
00700 
00701   <span class="keyword">private</span>:
00702 
00703   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00704   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00705   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00706                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00707                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00708 };
00709 
00710 <span class="preprocessor">#endif</span>
00711 <span class="preprocessor"></span>
00712 <span class="comment">// Define the following flag to have extra information spewed to stderr.</span>
00713 <span class="comment">//#define __RTAUDIO_DEBUG__</span>
00714 
00715 <span class="preprocessor">#endif</span>
</pre></div><HR>

<table><tr><td><img src="../images/mcgill.gif" width=165></td>
  <td>&copy;2001-2004 Gary P. Scavone, McGill University. All Rights Reserved.<br>
  Maintained by Gary P. Scavone, <a href="mailto:gary@music.mcgill.ca">gary@music.mcgill.ca</a></td></tr>
</table>

</BODY>
</HTML>
